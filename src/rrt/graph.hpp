#pragma once

#include <flann/flann.hpp>
#include <list>
#include <string.h>
#include <utility>
#include <vector>

/**
 * Class representing a Tree generated by the RRT algorithm. Each vertex stores it's coordinations in the
 * configuraion space C. Class is templated on the number of dimensions of the configuration space.
 */
template <int dimension> class Graph {
  public:
    struct Vertex {
        int id;
        double coords[dimension];
        std::list<std::pair<Vertex *, double>> edges; // outgoing edges with weights

        Vertex(int id, double coords[dimension]) : id(id) {
            memcpy(this->coords, coords, dimension * sizeof(this->coords[0]));
        }
    };

  private:
    int last_id = 0;
    std::vector<Vertex *> vertices;
    flann::Index<flann::L2<double>> index;

  public:
    Graph(double root_coords[dimension]) : index(flann::KDTreeIndexParams(4)) {
        // building flann index:
        flann::Matrix<double> point_matrix(root_coords, 1, dimension);
        index.buildIndex(point_matrix);

        Vertex *root = new Vertex(last_id, root_coords);
        vertices.push_back(root);
        last_id++;
    }

    ~Graph() {
        for (Vertex *vertex : vertices) {
            delete vertex;
        }
    }

    Vertex *add_vertex(double coords[dimension]) {
        // adding to flann index
        flann::Matrix<double> point_matrix(coords, 1, dimension);
        index.addPoints(point_matrix);

        // crating new vertex
        Vertex *new_vertex = new Vertex(last_id, coords);
        vertices.push_back(new_vertex);
        last_id++;

        return new_vertex;
    }

    Vertex *get_nearest(double query_coords[dimension]) {
        flann::Matrix<double> query_point(query_coords, 1, dimension);

        std::vector<std::vector<int>> indices;
        std::vector<std::vector<double>> dists;
        index.knnSearch(query_point, indices, dists, 1, flann::SearchParams(128));

        return vertices[indices[0][0]];
    }

    void add_edge(Vertex *from, Vertex *to, double weight) {
        from->edges.push_back(std::pair<Vertex *, double>(to, weight));
    }
};
